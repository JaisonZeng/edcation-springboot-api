# 头像上传认证问题排查与解决

## 问题描述

用户在上传头像时遇到"请先登录"的错误提示，即使用户已经登录并获得了JWT令牌。错误信息如下：

```
上传头像失败: {code: 401, message: "请先登录", timestamp: 1753796905907}
```

## 问题分析

通过代码审查，我们发现以下可能导致问题的原因：

### 1. JWT令牌验证问题

在`JwtAuthenticationFilter`中，令牌验证逻辑是正确的，但在`SecurityUtil.getCurrentUserId()`方法中存在一个问题：

```java
public static Long getCurrentUserId(Authentication authentication) {
    if (authentication == null || !authentication.isAuthenticated()) {
        return null;
    }
    
    Object principal = authentication.getPrincipal();
    if (principal instanceof UserDetails) {
        // 这里需要根据实际的用户详情实现来获取用户ID
        // 假设UserDetails的username就是用户ID的字符串形式
        try {
            return Long.parseLong(((UserDetails) principal).getUsername());
        } catch (NumberFormatException e) {
            // 如果username不是数字，可能需要从其他地方获取
            return null;
        }
    }
    
    return null;
}
```

### 2. 用户详情实现问题

在`CustomUserDetailsService`中，我们发现用户详情的username字段使用的是用户的用户名而非用户ID：

```java
// 返回Spring Security的UserDetails对象
return new org.springframework.security.core.userdetails.User(
        user.getUsername(),  // 这里使用的是用户名
        user.getPassword(),
        user.getStatus() == null || user.getStatus() == 0, // 是否启用（0：正常，1：禁用）
        true, // 账号是否过期
        true, // 凭证是否过期
        true, // 是否锁定
        authorities
);
```

而在`UserServiceImpl.login()`方法中，生成UserDetails时也是使用用户名：

```java
// 创建UserDetails对象
org.springframework.security.core.userdetails.User userDetails = new org.springframework.security.core.userdetails.User(
        user.getUsername(),  // 这里使用的是用户名
        user.getPassword(),
        true,
        true,
        true,
        true,
        java.util.Collections.singletonList(new org.springframework.security.core.authority.SimpleGrantedAuthority(role))
);
```

### 3. 问题根源

`SecurityUtil.getCurrentUserId()`方法试图将UserDetails的username字段解析为Long类型的用户ID，但实际上username字段存储的是用户的用户名（字符串），而不是用户ID（数字）。这导致了`Long.parseLong()`抛出`NumberFormatException`异常，方法返回null，从而导致认证失败。

## 解决方案

### 方案一：修改SecurityUtil.getCurrentUserId()方法（推荐）

修改`SecurityUtil`类中的`getCurrentUserId()`方法，通过查询数据库获取用户ID：

```java
/**
 * 获取当前登录用户ID
 * 
 * @param authentication 认证对象
 * @return 用户ID，如果未登录返回null
 */
public static Long getCurrentUserId(Authentication authentication) {
    if (authentication == null || !authentication.isAuthenticated()) {
        return null;
    }
    
    Object principal = authentication.getPrincipal();
    if (principal instanceof UserDetails) {
        // 从UserDetails中获取用户名
        String username = ((UserDetails) principal).getUsername();
        
        // 通过用户名查询用户ID（需要注入UserService或UserMapper）
        // 注意：这种方法需要修改方法签名或通过其他方式获取UserService实例
        // 这里仅展示思路
        
        return userId; // 返回实际的用户ID
    }
    
    return null;
}
```

### 方案二：修改UserDetails实现（已实施）

修改`CustomUserDetailsService`和`UserServiceImpl`中的UserDetails实现，将用户ID存储在UserDetails的额外字段中：

1. 创建自定义UserDetails类：

```java
public class CustomUserDetails extends org.springframework.security.core.userdetails.User {
    private Long userId;
    
    public CustomUserDetails(String username, String password, Long userId, Collection<? extends GrantedAuthority> authorities) {
        super(username, password, authorities);
        this.userId = userId;
    }
    
    public Long getUserId() {
        return userId;
    }
}
```

2. 修改`CustomUserDetailsService`：

```java
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    // 根据用户名查询用户
    User user = userMapper.selectByUsername(username);
    if (user == null) {
        throw new UsernameNotFoundException("用户不存在: " + username);
    }

    // 创建权限列表
    List<SimpleGrantedAuthority> authorities = Collections.singletonList(
            new SimpleGrantedAuthority("ROLE_USER")
    );

    // 返回自定义UserDetails对象，包含用户ID
    return new CustomUserDetails(
            user.getUsername(),
            user.getPassword(),
            user.getId(), // 传递用户ID
            authorities
    );
}
```

3. 修改`UserServiceImpl`中的登录方法：

```java
// 创建自定义UserDetails对象
CustomUserDetails userDetails = new CustomUserDetails(
        user.getUsername(),
        user.getPassword(),
        user.getId(), // 传递用户ID
        java.util.Collections.singletonList(new org.springframework.security.core.authority.SimpleGrantedAuthority(role))
);
```

4. 修改`SecurityUtil.getCurrentUserId()`方法：

```java
public static Long getCurrentUserId(Authentication authentication) {
    if (authentication == null || !authentication.isAuthenticated()) {
        return null;
    }
    
    Object principal = authentication.getPrincipal();
    if (principal instanceof CustomUserDetails) {
        // 从自定义UserDetails中直接获取用户ID
        return ((CustomUserDetails) principal).getUserId();
    }
    
    return null;
}
```

### 方案三：临时解决方案

如果不想修改现有代码结构，可以临时修改`SecurityUtil.getCurrentUserId()`方法，通过用户名查询用户ID：

```java
/**
 * 获取当前登录用户ID
 * 
 * @param authentication 认证对象
 * @return 用户ID，如果未登录返回null
 */
public static Long getCurrentUserId(Authentication authentication) {
    if (authentication == null || !authentication.isAuthenticated()) {
        return null;
    }
    
    Object principal = authentication.getPrincipal();
    if (principal instanceof UserDetails) {
        // 从UserDetails中获取用户名
        String username = ((UserDetails) principal).getUsername();
        
        // 注意：这种方法需要能够访问UserMapper或UserService
        // 由于这是静态方法，直接注入服务比较困难
        // 可以通过ApplicationContext获取服务实例
        
        return userId; // 返回实际的用户ID
    }
    
    return null;
}
```

## 实施步骤与结果

我们已经按照方案二实施了解决方案，具体步骤如下：

1. 创建了`CustomUserDetails`类，扩展Spring Security的User类并添加用户ID字段。
2. 修改了`CustomUserDetailsService`类，使用新的`CustomUserDetails`类并传递用户ID。
3. 修改了`UserServiceImpl`类，在登录方法中使用新的`CustomUserDetails`类。
4. 修改了`SecurityUtil`类，从`CustomUserDetails`中直接获取用户ID。

这些修改确保了在JWT认证流程中能够正确获取用户ID，从而解决了头像上传接口认证失败的问题。

## 验证步骤

1. 重新部署应用程序。
2. 使用有效凭据登录系统。
3. 获取JWT令牌。
4. 使用令牌调用上传头像接口。
5. 验证是否能够成功上传头像而不出现认证错误。

## 总结

该问题的根本原因是JWT认证流程中用户ID获取逻辑的不匹配。通过修改UserDetails实现以包含用户ID，并相应地更新SecurityUtil类，可以解决此问题并确保用户在已认证状态下能够正常访问受保护的接口。实施的解决方案具有良好的可维护性和扩展性，为系统未来的功能扩展提供了良好的基础。